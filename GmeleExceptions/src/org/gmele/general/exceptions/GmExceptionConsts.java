
package org.gmele.general.exceptions;

/**
 * Το interface GmExceptionConsts περιέχει ένα δείγμα ορισμού σταθερών για την κλάση {@link GmException} καθώς και τις σταθερές που θα
 * χρησιμοποιηθούν από την χρήση της κλάσης χωρίς αυτή να κληρονομηθεί (π.χ σε γενικές κλάσεις που βρίσκονται σε πακέτα κάτω από το 
 * "org.gmele.general"). Οι κωδικοί λαθών για κάθε εφαρμογή ή κλάση ορίζονται σε πακέτα των 1000.<p>
 * Κάθε κωδικός λάθους ορίζεται με σταθερά που να δηλώνει την κλάση ή την εφαρμογή που τον δημιουργεί και συνοδεύται από αναλυτική περιγραφή
 * σε μορφή javadoc.
 * @author Giorgos Meletiou
 * @version 1.0
 */
public interface GmExceptionConsts
{

    /**
     * Κωδικός λάθους 0. Δεν θα συμβεί ποτέ.
     */
    public final int GenSystemΝοError = 0;
    
    /**
     * Λείπει κάποια βιβλιοθήκη και δημιουργήθηκε ClassNotFoundException. Π.Χ. λείπει ο mysql driver.
     */
    public final int GenCannotLoadClass = 1;
    
    /**
     * Δημιουργήθηκε κάποια εξαίρεση η οποία δεν είχε προβλεφτεί στο συγκεκριμένο σημείο του προγράμματος. Για παράδειγμα, σε μία λειτουργία
     * πρόσβασης σε βάση δεδομένων αναμένεται να συμβούν δύο διαφορετικού τύπου εξαιρέσεις η παγίδευση των οποίων δημιουργεί 
     * {@link GmException} με δύο σχετικούς κωδικούς λάθους. Αν συμβεί μία τρίτη εξαίρεση, μη αναμενόμενη στο συγκεκριμένο τμήμα κώδικα,
     * η GmException θα έχει ως κωδικό λάθους GenUnexpectedException σε μία βάση δεδομένων αν γίνει έλεγχος για ένα ή δύο τύπους εξαίρεσης
     * που αναμένεται να συμβούν από το σύστημα και που η και δημιουργηθεί κάποιου άλλου τύπου εξαίρεσης τότε η κλάση δημιουργεί εξαίρεση. 
     */
    public final int GenUnexpectedException = 2;
    
    /**
     * Δημιουργήθηκε εξαίρεση η οποία δεν θα έπρεπε να συμβεί με κανένα τρόπο. Για παράδειγμα κατά τη διάρκεια διαβάσματος αντικειμένου από
     * αρχείο (serialiazation) η κλάση του αντικειμένου δεν έχει οριστεί. <p>
     * Χρησιμοποιείται στις GMele βιβλιοθήκες όταν συμβεί εξαίρεση που η Java απαιτεί τον χειρισμό της, αλλά κανονικά δεν υπάρχει περίπτωση
     * να συμβεί. Στο προηγούμενο παράδειγμα ο κωδικός θα δημιουργούνταν αν η μέθοδος ObjectInputStream.readObject δημιουργούσε 
     * ClassNotFoundException.  
     */
    public final int GenImpossibleException = 3;
    
    //Counter Errors
    /**
     * Το πάνω όριο του μετρητή είναι μικρότερο από το κάτω.
     */
    public final int CountInvalidLimits = 100;
    
    /**
     * Η αρχικοποίηση του πίνακα εξαιρούμενων τιμών γίνεται με πίνακα ο οποίος περιέχει λανθασμένες τιμές. Το λάθος μπορεί να αφορά την τιμή
     * του ψηφίου που μπορεί να είναι εκτός του μεγέθους του μετρητή ή την τιμή που εξαιρείται η οποία μπορεί να είναι εκτός των ορίων.
     */
    public final int CountBadOutMat = 101;
    
    /**
     * Άκυρος αριθμός ψηφίων. 
     */
    public final int CountInvalidSize = 102;
    
    
    //DbConnections Errors
    /**
     * Δεν μπορεί να δημιουργηθεί νέα απλή σύνδεση με τη MySql. Υπάρχουν πολλές ενεργές συνδέσεις.
     */
    public final int SimConCannotGetCon = 1000;

    /**
     * Λάθος όνομα Βάσης Δεδομένων ή logname ή password
     */
    public final int SimConDataError = 1001;
    
    //Crypto Errors
    /**
     * Δεν μπορεί να διαβαστεί το πηγαίο αρχείο στην κρυπτογράφηση / αποκρυπτογράφηση. Το αρχείο είναι ανύπαρκτο ή δεν υπάρχουν δικαιώματα
     * ανάγνωσης.
     */
    public final int CryptCannotReadFile = 1100;
    
    /**
     * Το αρχείο προορισμού στην κρυπτογράφηση / αποκρυπτογράφηση δεν μπορεί να δημιουργηθεί. Το όνομα είναι λάθος ή δεν μπορεί να
     * δημιουργηθεί λόγω δικαιωμάτων.
     */
    public final int CryptCannotCreateFile = 1101;
    
    /**
     * Συνέβη IOError κατά την διάρκεια γραψίματος δεδομένων στο αρχείο προορισμού κατά την κρυπτογράφηση / αποκρυπτογράφηση / καταστροφή.
     */
    public final int CryptCannotWriteFile = 1102;
    
    /**
     * Λανθασμένο password στην AES Αποκρυπτογράφηση. Διαπιστώνεται από το σύστημα λόγω του PCS5Padding.
     */
    public final int CryptInvalidPassword = 1103;
     


}
